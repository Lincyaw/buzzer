// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ebpf

import (
	"fmt"
)

// IMMJMPInstruction Represents an eBPF jump (branching) operation.
type IMMJMPInstruction struct {

	// Add all the basic things all instructions have.
	BaseInstruction

	// DstReg is from where the value to compare for the jump will be taken.
	DstReg *Register

	// Imm is the immediate value that will be used as the other comparing
	// operand.
	Imm int32

	// TrueBranchNextInstr instruction that will be executed if the operation
	// evaluates to true.
	TrueBranchNextInstr Instruction
	trueBranchGenerator func(prog *Program) Instruction

	// FalseBranchNextInstr is the instruction that will be executed if
	// the operation evaluates to false.
	FalseBranchNextInstr Instruction

	// FalseBranchSize is how many instructions there are in the false
	// branch.
	FalseBranchSize      int16
	falseBranchGenerator func(prog *Program) (Instruction, int16)
}

// GenerateBytecode generates the bytecode associated with this instruction.
func (c *IMMJMPInstruction) GenerateBytecode() []uint64 {
	bytecode := []uint64{encodeImmediateJmpInstruction(c.Opcode, c.InstructionClass, c.DstReg.RegisterNumber(), c.Imm, c.FalseBranchSize)}
	if c.FalseBranchNextInstr != nil {
		// Only take the `c.FalseBranchSize` number of opcodes of the
		// false brach generated bytecode.
		falseBranchBytecode := c.FalseBranchNextInstr.GenerateBytecode()[0:c.FalseBranchSize]
		bytecode = append(bytecode, falseBranchBytecode...)
	}
	if c.TrueBranchNextInstr != nil {
		bytecode = append(bytecode, c.TrueBranchNextInstr.GenerateBytecode()...)
	}
	return bytecode
}

// GenerateNextInstruction uses the prog generator to create the rest of the tree.
func (c *IMMJMPInstruction) GenerateNextInstruction(prog *Program) {
	if c.FalseBranchNextInstr != nil {
		c.FalseBranchNextInstr.GenerateNextInstruction(prog)
	} else if c.falseBranchGenerator != nil {
		nextInstruction, bSize := c.falseBranchGenerator(prog)
		c.FalseBranchNextInstr = nextInstruction
		c.FalseBranchSize = bSize
	}

	if c.TrueBranchNextInstr != nil {
		c.TrueBranchNextInstr.GenerateNextInstruction(prog)
	} else if c.trueBranchGenerator != nil {
		c.TrueBranchNextInstr = c.trueBranchGenerator(prog)
	}
}

// NumerateInstruction sets the instruction number recursively
func (c *IMMJMPInstruction) NumerateInstruction(instrNo uint32) int {
	c.instructionNumber = instrNo
	instrNo++

	// This logic will result in us traversing the tree in dfs twice
	// (if we also need to traverse the true branch). But for now
	// this is the best idea I can come up with to numerate instructions
	// on conditional branches.
	if c.FalseBranchNextInstr != nil {
		c.FalseBranchNextInstr.NumerateInstruction(instrNo)
	}

	instrNo += uint32(c.FalseBranchSize)

	if c.TrueBranchNextInstr != nil {
		return 1 + int(c.FalseBranchSize) + c.TrueBranchNextInstr.NumerateInstruction(instrNo)
	}

	return 1 + int(c.FalseBranchSize)
}

// SetNextInstruction manually sets the next instruction.
func (c *IMMJMPInstruction) SetNextInstruction(next Instruction) {
	// For now, always pass the next instruction to the true branch.
	if c.TrueBranchNextInstr != nil {
		c.TrueBranchNextInstr.SetNextInstruction(next)
	} else {
		c.TrueBranchNextInstr = next
	}
}

// GetNextInstruction returns the next instruction, mostly used for testing
// purposes.
func (c *IMMJMPInstruction) GetNextInstruction() Instruction {
	// For now only return the true branch next instr.
	return c.TrueBranchNextInstr
}

// GeneratePoc generates the C macros to repro this program.
func (c *IMMJMPInstruction) GeneratePoc() []string {
	if c.Opcode == JmpExit {
		return []string{"BPF_EXIT_INSN()"}
	}
	var insClass string
	if c.InstructionClass == InsClassJmp {
		insClass = "BPF_JMP"
	} else {
		insClass = "BPF_JMP32"
	}
	insName := NameForJmpInstruction(c.Opcode)
	regName := c.DstReg.ToString()
	macro := fmt.Sprintf("BPF_JMP_IMM(%s, /*dst=*/%s, /*imm=*/%d, /*off=*/%d, /*ins_class=*/%s)", insName, regName, c.Imm, c.FalseBranchSize, insClass)
	r := []string{macro}
	if c.FalseBranchNextInstr != nil {
		r = append(r, c.FalseBranchNextInstr.GeneratePoc()...)
	}
	if c.TrueBranchNextInstr != nil {
		r = append(r, c.TrueBranchNextInstr.GeneratePoc()...)
	}
	return r
}

// ExitInstruction Terminates the execution of a given program.
func ExitInstruction() Instruction {
	return &IMMJMPInstruction{BaseInstruction: BaseInstruction{Opcode: JmpExit, InstructionClass: InsClassJmp}, Imm: UnusedField, DstReg: RegR0}
}

// GuardJump Generates a jmp instruction where false branch of the jump will
// terminate the program.
func GuardJump(ins, insClass uint8, dstReg *Register, imm int32) *IMMJMPInstruction {
	jmp := &IMMJMPInstruction{BaseInstruction: BaseInstruction{Opcode: ins, InstructionClass: insClass}, Imm: imm, DstReg: dstReg}
	jmp.falseBranchGenerator = func(prog *Program) (Instruction, int16) {
		// We return 1 because an Exit Instruction has 1 opcode.
		return ExitInstruction(), 1
	}
	jmp.trueBranchGenerator = func(prog *Program) Instruction {
		return prog.Gen.GenerateNextInstruction(prog)
	}
	return jmp
}

// CallInstruction represents a call to an ebpf auxiliary function.
type CallInstruction struct {

	// Add all the basic things all instructions have.
	BaseInstruction

	fnNumber int32
}

// GenerateBytecode generates the bytecode associated with this instruction.
func (c *CallInstruction) GenerateBytecode() []uint64 {
	bytecode := []uint64{encodeImmediateJmpInstruction(JmpCALL, InsClassJmp, UnusedField, c.fnNumber /*offset=*/, 0)}
	if c.nextInstruction != nil {
		bytecode = append(bytecode, c.nextInstruction.GenerateBytecode()...)
	}
	return bytecode
}

// GeneratePoc generates the C macros to repro this program.
func (c *CallInstruction) GeneratePoc() []string {
	macro := fmt.Sprintf("BPF_CALL_FUNC(%s)", GetBpfFuncName(c.fnNumber))
	r := []string{macro}
	if c.nextInstruction != nil {
		r = append(r, c.nextInstruction.GeneratePoc()...)
	}
	return r
}

// CallFunction is an auxiliary function that returns an EBPFCallInstruction
// structure.
func CallFunction(functionValue int32) Instruction {
	return &CallInstruction{fnNumber: functionValue}
}

// RegJMPInstruction Represents an eBPF jump (branching) operation.
type RegJMPInstruction struct {

	// Add all the basic things all instructions have.
	BaseInstruction

	// DstReg is from where the value to compare for the jump will be taken.
	DstReg *Register

	// SrcReg holds the value that will be used as the other comparing
	// operand.
	SrcReg *Register

	// TrueBranchNextInstr instruction that will be executed if the operation
	// evaluates to true.
	TrueBranchNextInstr Instruction
	trueBranchGenerator func(prog *Program) Instruction

	// FalseBranchNextInstr is the instruction that will be executed if
	// the operation evaluates to false.
	FalseBranchNextInstr Instruction

	// FalseBranchSize is how many instructions there are in the false
	// branch.
	FalseBranchSize      int16
	falseBranchGenerator func(prog *Program) (Instruction, int16)
}

// GenerateBytecode generates the bytecode for this instruction.
func (c *RegJMPInstruction) GenerateBytecode() []uint64 {
	bytecode := []uint64{encodeRegisterJmpInstruction(c.Opcode, c.InstructionClass, c.DstReg.RegisterNumber(), c.SrcReg.RegisterNumber(), c.FalseBranchSize)}
	if c.FalseBranchNextInstr != nil {
		// Only take the `c.FalseBranchSize` number of opcodes of the
		// false brach generated bytecode.
		falseBranchBytecode := c.FalseBranchNextInstr.GenerateBytecode()[0:c.FalseBranchSize]
		bytecode = append(bytecode, falseBranchBytecode...)
	}
	if c.TrueBranchNextInstr != nil {
		bytecode = append(bytecode, c.TrueBranchNextInstr.GenerateBytecode()...)
	}
	return bytecode
}

// GenerateNextInstruction builds the next instruction for this operation.
func (c *RegJMPInstruction) GenerateNextInstruction(prog *Program) {
	if c.FalseBranchNextInstr != nil {
		c.FalseBranchNextInstr.GenerateNextInstruction(prog)
	} else if c.falseBranchGenerator != nil {
		nextInstruction, bSize := c.falseBranchGenerator(prog)
		c.FalseBranchNextInstr = nextInstruction
		c.FalseBranchSize = bSize
	}

	if c.TrueBranchNextInstr != nil {
		c.TrueBranchNextInstr.GenerateNextInstruction(prog)
	} else if c.trueBranchGenerator != nil {
		c.TrueBranchNextInstr = c.trueBranchGenerator(prog)
	}
}

// SetNextInstruction sets the next instruction for this operation.
func (c *RegJMPInstruction) SetNextInstruction(next Instruction) {
	// For now, always pass the next instruction to the true branch.
	if c.TrueBranchNextInstr != nil {
		c.TrueBranchNextInstr.SetNextInstruction(next)
	} else {
		c.TrueBranchNextInstr = next
	}
}

// GetNextInstruction returns the next instruction, mostly used for testing
// purposes.
func (c *RegJMPInstruction) GetNextInstruction() Instruction {
	// For now only return the true branch next instr.
	return c.TrueBranchNextInstr
}

// NumerateInstruction sets the instruction numbers recursively.
func (c *RegJMPInstruction) NumerateInstruction(instrNo uint32) int {
	c.instructionNumber = instrNo
	instrNo++

	// This logic will result in us traversing the tree in dfs twice
	// (if we also need to traverse the true branch). But for now
	// this is the best idea I can come up with to numerate instructions
	// on conditional branches.
	if c.FalseBranchNextInstr != nil {
		c.FalseBranchNextInstr.NumerateInstruction(instrNo)
	}

	instrNo += uint32(c.FalseBranchSize)

	if c.TrueBranchNextInstr != nil {
		return 1 + int(c.FalseBranchSize) + c.TrueBranchNextInstr.NumerateInstruction(instrNo)
	}

	return 1 + int(c.FalseBranchSize)
}

// GeneratePoc generates the C macros to repro this program.
func (c *RegJMPInstruction) GeneratePoc() []string {
	var insClass string
	if c.InstructionClass == InsClassJmp {
		insClass = "BPF_JMP"
	} else {
		insClass = "BPF_JMP32"
	}
	insName := NameForJmpInstruction(c.Opcode)
	dstRegName := c.DstReg.ToString()
	srcRegName := c.SrcReg.ToString()
	macro := fmt.Sprintf("BPF_JMP_REG(%s, /*dst=*/%s, /*src=*/%s, /*off=*/%d, /*ins_class=*/%s)", insName, dstRegName, srcRegName, c.FalseBranchSize, insClass)
	r := []string{macro}
	if c.FalseBranchNextInstr != nil {
		r = append(r, c.FalseBranchNextInstr.GeneratePoc()...)
	}
	if c.TrueBranchNextInstr != nil {
		r = append(r, c.TrueBranchNextInstr.GeneratePoc()...)
	}
	return r
}
